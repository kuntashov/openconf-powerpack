<?xml version="1.0" encoding="windows-1251" ?>
<!--
	Copyright (c) 2005 OpenConf Community <http://openconf.itland.ru>

	$Id: $

	Авторы:  
		Александр Кунташов aka a13x <kuntashov@yandex.ru> icq#338758861  
-->
<package>
<component>
<?component error="true" debug="true"?>

<registration
	description="ScriptManager component for OpenConf"
	progid="OpenConf.ScriptManager"
	version="1.00"
	classid="{71b26c99-34a3-6e54-1ab4-ca7ac380d466}">
</registration>

<comment>Библиотека типов OpenConf'а</comment> 
<reference guid="{578f85c8-89eb-4cda-ac7e-8f3bb34e8b54}" /> 
<!-- object id="OCS" progid="OpenConf.CommonServices" / -->
<object id="FSO" progid="Scripting.FileSystemObject" />

<public>

	<method name="OnInit">
		<parameter name="HotKeyEventProxy" />
		<parameter name="Configurator" />
	</method>

	<method name="OnHotKey">
		<parameter name="HotKey" />
	</method>

</public>

<script language="JavaScript">
<![CDATA[

var _debug = true;

var Config = null;
var HKEP = null;
var ActiveKeyMap = null;

var SCache;

function OnInit(HotKeyEventProxy, Configurator)
{	
	HKEP = HotKeyEventProxy;
	Config = Configurator;

	ActiveKeyMap = LoadKeyMap("c:\\1Cv77\\bin\\config\\system\\ScriptManager\\default.keymap.js");
	if (!ActiveKeyMap) return;

	SCache = new ScriptCache();

	LoadScripts();
}

function OnHotKey(HotKey)
{
	var hki = ActiveKeyMap.getHKInfo(HotKey);
	if (!hki) {
		error("Для хоткея " + HotKey 
			+ " не назначена ни одна команда ни в одном из контекстов");
		return;
	}

	var ctx = GetContext();

	/* 	"Глобальный" хоткей - это хоткей, который выполняется независимо от
	 * текущего контекста, т.е. хоткей, по которому в любом окне выполняется
	 * одно и то же действие независимо от типа окна (так ведет себя ОпенКонф
	 * по умолчанию). 
	 * 	Такую ситуацию можно смоделировать назначив одну и ту же команду (макрос)
	 * для всех контекстов вызова хоткея.
	 *	Но чтобы сделать наш кеймап проще и исключить дублирование описаний 
	 * обработчика контекста, примем следующее соглашение: если для контекста
	 * 0 ("нет активного окна") назначен обработчик, а для всех остальных нет -
	 * то будем считать, что это есть команда (макрос) для выполнения независимо,
	 * от контекста, т.е. хоткей является глобальным.
	 */

	// проверяем хоткей на "глобальность"
	var global = true;
	for(var i=1; i<hki.length; i++) {		
		global = global && !((typeof(hki[i])=='object')&&(hki[i].macros));
		if (!global) break;
	}

	if (global) ctx = 0;
	
	var info = hki[ctx];

	if (!info.macros) {
		error("Не задан макрос для хоткея " + HotKey + "(Контекст: " + ctx + ")");
		return;
	}

	if (!info.script) {
		// это команда, выполняем ее
		RunCommand(info.macros);
		return;
	}
	
	if (!IsScriptLoaded(info.script)) {
		if (!(info.path && LoadScript(info.path))) {
			return;
		}
	}
	
	CallMacros(info.script, info.macros);

	if (info.runOnce) {
		UnloadScript(info.path);
	}	
}

/*
При загрузке - загружаются скрипты из заданных в файле Folders.lst директорий
	- игнорируются файлы по маске
		- TODO глобальная маска для всех файлов
		- TODO локальные (для данной директории) маски из файла .ignore
		- файлы, начинающиеся с '.'
		- файлы в директориях 'CVS' и 'SVN'
		- скрытые файлы (с установленным атрибутом hidden)
*/

function LoadScripts()
{
	var Folders_lst = FSO.BuildPath(Config.BinDir, "config\\system\\ScriptManager\\Folders.lst");
	var folders = FSO.OpenTextFile(Folders_lst).ReadAll().split(/\r\n/);
	for(var i=0; i<folders.length; i++) {
		if (FSO.FolderExists(folders[i])) {
			LoadScriptsFromFolder(FSO.GetFolder(folders[i]));
		}
	}
}

function LoadScriptsFromFolder(folder)
{
	LoadScriptsInFolder(folder);
	var subs = new Enumerator(folder.SubFolders);
	for(; !subs.atEnd(); subs.moveNext()) {
		var sub = subs.item();
		if (CheckPath(sub)) {
			LoadScriptsFromFolder(sub);
		}
	}
}

function LoadScriptsInFolder(folder)
{
	var files = new Enumerator(folder.files);
	for(; !files.atEnd(); files.moveNext()) {
		var file = files.item();
		if (CheckPath(file)) {
			LoadScript(file.Path);
		}
	}
}

function CheckPath(FSObj)
{
	with (FSObj) {
		return((Name.charAt(0)!='.')
			&& (Name!='CVS')			
			&& (!(FSObj.Attributes&2)));
	}
}

function LoadScript(path)
{
	try {
		var Script = Config.Scripts.Load(path);
		SCache.add(Script.Name, path)
		return true;
	}
	catch (e) {
		error("Не могу загрузить скрипт " + path, e);		
		return false;
	}
}

function IsScriptLoaded(ScriptName)
{
	if (SCache.exists(ScriptName)) return true;
	for (var i=0; i<Config.Scripts.Count; i++) {
		if (Config.Scripts.Name(i) == ScriptName) {
			// дабы исключить перебор в следующий раз, кэшируем
			SCache.add(ScriptName, Config.Scripts.path(i));
			return true;
		}
	}
	return false;
}

function UnloadScript(ScriptName)
{
	if (IsScriptLoaded(fname)) {
		try {
			Config.Scripts.UnLoad(ScriptName);
			SCache.del(ScriptName);
			return true;
		}
		catch (e) {
			error("Ошибка выгрузки скрипта: " + ScriptName, e);			
			return false;
		}
	}
}

/*	Различаются следующие контексты:
 *		0 - нет открытых окон
 *		1 - открыто и активно окно конфигурации, закладка Метаданные
 *		2 - открыто и активно окно конфигурации, закладка Интерфейсы
 *		3 - открыто и активно окно конфигурации, закладка Права 
 *		4 - открыто и активно окно конфигурации, другие закладки (OpenConf или плагины)
 *		5 - открыто и активно окно редактора текстов
 *		6 - открыто и активно окно редактора форм
 *		7 - открыто и активно окно редактора таблиц
 *		8 - есть активное окно, но тип документа не определен (docUnknown)
 */
function GetContext()
{
	var win = Config.Windows.ActiveWnd;
	if (!win) {	
		return 0;
	}

	// активное окно - это окно конфигурации?
	if (win == Config.MDWnd.hWnd) {
		var at = Config.MDWnd.ActiveTab;
		/* закладки с индексами 0 (Метаданные), 1 (Интерфейсы) и 2 (Права)
		 * выделяем как отдельные контексты, остальные закладки рассматриваем 
		 * как один контекст (закладки OpenConf'а и плагинов)
		 */		
		return ((-1<at)&&(at<3) ? at+1 : 4);
	}		

	// нет, это окно какого-либо документа
	var doc = win.Document;
	if (doc == docWorkBook) {
		doc = doc.Page(doc.ActivePage);
	}
	// каждый тип документа в активном окне образует свой контекст
	switch (doc.Type) {
		case docText	: return 5; // окно редактора текстов
		case docDEdit	: return 6; // окно редактора форм
		case docTable	: return 7; // окно редактора таблиц
		default			: return 8; // неизвестный тип окна
	}	
}

function ContextToString(context)
{
	switch (context) {
		case 0	: return "нет открытых окон";
		case 1	: return "окно конфигурации, закладка Метаданные";
		case 2	: return "окно конфигурации, закладка Интерфейсы";
		case 3	: return "окно конфигурации, закладка Права";
		case 4	: return "окно конфигурации, другие закладки (OpenConf или плагины)";
		case 5	: return "окно редактора текстов";
		case 6	: return "окно редактора форм";
		case 7	: return "окно редактора таблиц";
		default	: return "окно неопределенного типа";			
	}
}

function RunCommand(cmd)
{
}

function CallMacros(ScriptName, Macros)
{
	try {
		Config.Scripts(ScriptName)[Macros]();
		return true;
	}
	catch (e) {			
		error("Ошибка выполнения макроса " + ScriptName + "::" + Macros, e);
		return false;
	}
}

function LoadKeyMap(path)
{
	var kmap = new KeyMap(path);
	return kmap.Load()?kmap:null;
}

//TODO Оформить и импользовать как компонент, а не JS-класс
function KeyMap(path)
{	
//private
	var hk = {};
	
//public
	this.path = path;

	this.Load = function (p)
	{
		hk = {}
		if(p) this.path = p;

		var fso = new ActiveXObject("Scripting.FileSystemObject");
		if (!fso.FileExists(this.path)) {
			return false;
		}
		try {
			var cfg = fso.OpenTextFile(this.path).ReadAll();
			eval(cfg);
			return true;
		}
		catch (e) {			
			error("Ошибка загрузки кеймапа " + this.path, e);
			return false;
		}
	}
	this.Save = function (p)
	{
		var savePath = p?p:this.path;
		// TODO 
	}
	this.getHKInfo = function (mnemo, context)
	{
		if (mnemo) {
			if (hk[mnemo] instanceof Array) {
				if (context!==undefined) {
					if ((!isNaN(context))&&(-1<context)&&(context<hk[mnemo].length)) {
						return hk[mnemo][context];
					}
				}
				else {
					return hk[mnemo]
				}
			}
		}
		return null;
	}
	this.setHKInfo = function (mnemo, info) 
	{
		var oldInfo = hk[mneno];
		hk[mnemo] = info; 
		return oldInfo;
	}
}

function ScriptCache()
{
	var cache = {};

	this.add = function(Name, Path) 
	{
		if (!cache[Name]) {
			cache[Name] = Path;
		}		
	}
	this.del = function (Name) 
	{
		if (cache[Name]) {
			cache[Name] = undefined;
		}
	}
	this.exists = function (Name)
	{	
		return cache[Name]?true:false;
	}
	this.getPath = function (Name)
	{
		return cache[Name];
	}
}

function _msg()
{
	if (!_debug) return;
	for (var i=0; i<arguments.length; i++) {
		Config.Message("{ScriptManager}: " + arguments[i]);
	}
}

function error(errmsg,e)
{
	Config.Message("{ScriptManager} " + errmsg, mRedErr);
	if (e) {
		if (e instanceof Error) {
			for (var a in e) {
				Config.Message("\t\t" + a + ": " + e[a]);
			}
			return;
		}
		Config.Message("\t\t" + e)
	}
}

]]>
</script>
</component>
</package> 
